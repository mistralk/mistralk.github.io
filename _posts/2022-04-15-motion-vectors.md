---
toc: false
layout: post
description: 
categories: dev/research
title: 모션 벡터
---

렌더링에서 모션 벡터를 어떻게 계산하는지, 그리고 어떤 상황에서 잘못된 모션 벡터가 생성되는지 알아보자. <!--more-->Zeng et al.의 2021년 논문 Temporally Reliable Motion Vectors for Real‐time Ray Tracing [1] 및 그에 대한 Ray Tracing Gems 2 기사 [2]의 백그라운드 설명 섹션을 주로 참고했다.

## 백프로젝션을 통해 모션 벡터 계산하기

직전 프레임 $$i-1$$과 현재 프레임 $$i$$가 주어졌을때, 프레임간에 물체들이 어떤 방향으로 이동했는지를 벡터로 표현할 수 있다. 이를 **모션 벡터**라고 한다. 모션 벡터를 계산하려면 먼저 물체 표면이 이전 프레임에선 어느 픽셀에 위치했었는지 알아야만 한다.

문제를 좀더 포멀하게 정리해보겠다. 현재 프레임에서 카메라 레이와 교차한 픽셀을 $$X_i$$라고 하자. 그리고 카메라 레이가 씬의 어떤 물체 표면과 교차한 지점 - 즉 월드좌표계의 셰이딩 포인트를 $$S_i$$라고 하자. 즉, 이 $$S_i$$가 직전 프레임에선 과연 어느 픽셀 $$X_{i-1}$$에 프로젝션되고 있었을지 알고 싶다는 것이다. 

플로우를 계산하기 어려운 컴퓨터 비전 문제에서와는 다르게, 렌더링 문제에서는 필요한 정보가 거의 전부 주어지기 때문에 이를 비교적 간단히 계산할 수 있다. 한 픽셀을 이전 프레임으로 프로젝션하는 이 계산 과정을 **백프로젝션(back-projection)**이라고 한다. 

1. 픽셀 $$X_i$$를 $$i$$번째 프레임의 월드좌표계로 프로젝션한다.
2. 이를 지오메트리의 움직임에 따라 $$i-1$$번째 프레임으로 트랜스폼한다.
3. 트랜스폼된 $$i-1$$번째 프레임의 월드좌표계를 이미지 스페이스로 프로젝션한다.

백프로젝션을 완료하면 현재 프레임의 한 셰이딩 포인트가 이전 프레임에선 어디에 위치하고 있었는지에 대한 픽셀 좌표 $$X_{i-1}$$이 나온다. 

과정을 식으로 표현해보자. 먼저 어떤 프레임에 대해 뷰포트를 $$\mathbf{M}_v$$, 모델-뷰 프로젝션 변환 행렬을 $$\mathbf{M}_{mvp}$$라고 하자. 두 행렬의 곱을 다음처럼 나타낸다.

$$
\mathbf{P} = \mathbf{M}_v \mathbf{M}_{mvp}
$$

프레임 사이의 지오메트리 변환을 $$\mathbf{T}$$ 라고 하면, 이제 백프로젝션 과정을 다음 식으로 쓸 수 있다.

$$
X_{i-1} = \mathbf{P}_{i-1} \mathbf{T}^{-1} \mathbf{P}_i^{-1} X_i
$$

이제 모션 벡터를 간단히 계산할 수 있다.

$$
\mathbf{m}(X_i) = X_{i-1} - X_i
$$

## 잘못된 모션 벡터

계산은 쉽지만, 항상 '옳은' 모션 벡터가 생성되는 것은 아니다. 신뢰할 수 없는(즉 유효한 템포럴 정보를 담고 있지 않은) 모션 벡터가 생성되는 케이스들도 존재한다. 

- **그림자**: 정적인 섀도우 리시버에 그림자가 드리운 경우. 프레임에 걸쳐 광원이 이동하면서 그림자가 움직이는 상황
- **글로시 리플렉션**: 정적인 리플렉터에 물체가 반사된 경우. 프레임에 걸쳐 카메라가 이동하면서 리플렉션 이펙트가 움직이는 상황
- **오클루전**: 물체가 움직이면서, 이전에 해당 물체에 의해 가려져있던 구역에서 정적인 백그라운드가 나타난 상황

[논문 \[1\]의 보충 비디오](https://sites.cs.ucsb.edu/~lingqi/publications/video_trmv.mp4)에 각 케이스와 이로 인한 아티팩트가 잘 나타나 있다.

처음 두 케이스는 섀도우 리시버 또는 리플렉터 위에 길이가 0인 모션 벡터가 생성된다. 여러 프레임에 걸쳐 해당 물체가 정지되어 있기 때문이다. 하지만 물체의 위에 드리운 그림자 또는 글로시 리플렉션 이펙트는 (물체 자체는 멈춰있음에도) 광원이나 카메라의 움직임에 따라 움직일 수 있다. 결국 우리의 모션 벡터는 물체의 지오메트리만을 트래킹하고 있음에도, 실제 그림자 효과는 광원에 의존적이고 글로시 효과는 카메라 위치에 의존적이기 때문에 생기는 문제다. 길이 0의 모션 벡터는 이런 이펙트들의 움직임 정보를 담고 있지 않다.

오클루전은 조금 다른 케이스이다. 백그라운드의 해당 위치에 모션 벡터가 아예 존재하지 않는다. 이전 프레임에서는 어떤 물체에 의해 차폐되어 보이지 않던 구역이 현재 프레임에서는 보이기 때문이다. 즉 $$X_{i}$$에 상응하는 이전 프레임의 픽셀(temporal correspondence) $$X_{i-1}$$이 백그라운드에 존재하지 않으므로, 백프로젝션을 하더라도 옳은 모션 벡터를 정의할 수 없다.

이런 잘못된 모션 벡터를 그대로 렌더링에 사용할 경우 문제가 발생한다. 예를들어 템포럴 안티 에일리어싱(Temporal Anti-Aliasing, TAA)의 인풋으로 잘못된 모션 벡터를 넣으면 물체 궤적을 따라 잔상이 보이는 고스팅(ghosting) 아티팩트가 발생할 수 있다. 앞에서 링크한 보충 비디오가 그러한 아티팩트를 보여주고 있다.

## 결론

시간적인 정보까지 인풋으로 활용하는 렌더링 알고리즘들이 널리 사용됨에 따라 모션 벡터의 중요성도 커졌다. 앞에서 설명한 것처럼 간단한 리프로젝션만으로 모션 벡터를 생성할 수 있으니 안 쓰기엔 아깝다.

하지만 어느 상황에서나 완벽한 모션 벡터를 생성하기 위한 통일된 방법은 없다. 대신 개별 케이스에서 아티팩트를 방지하거나 완화하기 위한 여러 테크닉과 휴리스틱이 소개됐다. 이 글에서 주로 참고한 [1] 역시 위의 세 가지 상황에 대해 ‘믿을만한’ 모션 벡터를 생성하는 테크닉을 소개하는 논문이다.

## 레퍼런스

[1] Zeng, Zheng, et al. "Temporally Reliable Motion Vectors for Real‐time Ray Tracing." *Computer Graphics Forum*. Vol. 40. No. 2. 2021. [Author's version](https://sites.cs.ucsb.edu/~lingqi/publications/paper_trmv.pdf])

[2] Zeng, Zheng, et al. "Temporally Reliable Motion Vectors for Better Use of Temporal Information." *Ray Tracing Gems II*. Apress, Berkeley, CA, 2021. 401-416. [Official version](https://link.springer.com/content/pdf/10.1007/978-1-4842-7185-8_25.pdf)